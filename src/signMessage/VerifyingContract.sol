// SPDX-License-Identifier: MIT

pragma solidity ^0.8.20;

error Expired();

/// @title VerifyingContract
/// @author Priyanshu Bindal
/// @notice The contract verifies the signature generated by the user
contract VerifyingContract {
    bytes32 public immutable DOMAIN_SEPERATOR;
    /// chain id on which the contract is currently deployed
    uint256 public immutable CHAIN_ID;
    bytes32 public constant DOMAIN_TYPEHASH =
        keccak256("EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)");
    bytes32 public constant PERMIT_TYPEHASH =
        keccak256("Permit(address signer,string message,address verifyingContract,uint256 nonce,uint256 deadline)");

    /// name of the dapp
    string public name;
    /// version of the dapp
    string public version;

    mapping(address => uint256) public nonces;

    struct Permit {
        address signer;
        string message;
        address verifyingContract;
        uint256 nonce;
        uint256 deadline;
    }

    error InvalidSigner(address recoveredAddress, address signer);

    constructor() {
        CHAIN_ID = block.chainid;
        DOMAIN_SEPERATOR = computeDomainSeperator();
        name = "EIP712Contract";
        version = "1";
    }

    /// @notice Calculates the Domain Seperator
    /// @dev more values like salt can be added to generate domain seperator
    /// @return bytes32 returns the domain seperator
    function computeDomainSeperator() internal view returns (bytes32) {
        return (
            keccak256(
                abi.encode(DOMAIN_TYPEHASH, keccak256(bytes(name)), keccak256(bytes(version)), CHAIN_ID, address(this))
            )
        );
    }

    ///@dev Returns the value of domain used to generate domain seperator
    ///@return nameOfDapp Returns the name of the dapp
    ///@return currentVersion Returns the current verision of the dapp
    ///@return chainId Returns the chainId the contract is deployed to
    ///@return verifyingContract Returns the address of this contract
    function eip712Domain()
        public
        view
        returns (string memory nameOfDapp, string memory currentVersion, uint256 chainId, address verifyingContract)
    {
        return (name, version, CHAIN_ID, address(this));
    }

    ///@dev The function calculates the digest and recovers the Realsigner with the help of digest and (v,r,s) and checks if Realsigner matches the signer
    ///@param _permit The Permit struct with values to be signed
    ///@param v The v part of the signature
    ///@param r The r part of the signature
    ///@param s The s part of the signature
    ///@return bool Returns true if address recovered from the signature matches the signer
    function permit(Permit memory _permit, uint8 v, bytes32 r, bytes32 s) public returns (bool) {
        if(_permit.deadline > block.timestamp) revert Expired();
        
        bytes32 structHash = keccak256(
            abi.encode(
                PERMIT_TYPEHASH,
                _permit.signer,
                _permit.message,
                _permit.verifyingContract,
                nonces[_permit.signer],
                _permit.deadline
            )
        );
        bytes32 hash = keccak256(abi.encodePacked("\x19\x01", DOMAIN_SEPERATOR, structHash));
        address recoveredAddress = ecrecover(hash, v, r, s);
        if (recoveredAddress != _permit.signer) {
            revert InvalidSigner(recoveredAddress, _permit.signer);
        }
        nonces[_permit.signer] += 1;
        return true;
    }
}
